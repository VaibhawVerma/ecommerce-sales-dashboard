# -*- coding: utf-8 -*-
"""rfm_analysis.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/17sAn7dknxp3z5S3D8HUcLPKGjhHP-4ai
"""

import pandas as pd
import datetime as dt

# --- 1. LOAD THE CLEANED DATA ---
try:
    df = pd.read_csv('cleaned_retail_data.csv')
    # Convert InvoiceDate to datetime objects
    df['InvoiceDate'] = pd.to_datetime(df['InvoiceDate'])
    print("Successfully loaded the cleaned data.")
except FileNotFoundError:
    print("Error: 'cleaned_retail_data.csv' not found.")
    exit()

# --- 2. CALCULATE RFM METRICS ---

snapshot_date = df['InvoiceDate'].max() + dt.timedelta(days=1)
print(f"Snapshot date for Recency calculation: {snapshot_date}")

# Group data by each customer
rfm_data = df.groupby(['Customer ID']).agg({
    'InvoiceDate': lambda x: (snapshot_date - x.max()).days, # Recency: days since last purchase
    'Invoice': 'nunique',                                   # Frequency: count of unique invoices
    'TotalPrice': 'sum'                                     # Monetary: total spend
})

# Rename the columns to be more descriptive
rfm_data.rename(columns={'InvoiceDate': 'Recency',
                         'Invoice': 'Frequency',
                         'TotalPrice': 'MonetaryValue'}, inplace=True)

print("\n--- RFM Metrics Calculated (First 5 rows): ---")
print(rfm_data.head())

# --- 3. CREATE RFM SEGMENTS ---


r_labels = range(4, 0, -1) # 4 is best (most recent), 1 is worst
f_labels = range(1, 5)     # 4 is best (most frequent), 1 is worst
m_labels = range(1, 5)     # 4 is best (most valuable), 1 is worst

# Create quartile-based scores for each metric using rank() to handle duplicates
rfm_data['R_Score'] = pd.qcut(rfm_data['Recency'].rank(method='first'), q=4, labels=r_labels).astype(int)
rfm_data['F_Score'] = pd.qcut(rfm_data['Frequency'].rank(method='first'), q=4, labels=f_labels).astype(int)
rfm_data['M_Score'] = pd.qcut(rfm_data['MonetaryValue'].rank(method='first'), q=4, labels=m_labels).astype(int)

# Combine the scores to create a single RFM Score
rfm_data['RFM_Score'] = rfm_data['R_Score'].astype(str) + rfm_data['F_Score'].astype(str) + rfm_data['M_Score'].astype(str)


# Define segments based on the scores
def assign_segment(df):
    if df['R_Score'] >= 4 and df['F_Score'] >= 4:
        return 'Champions'
    elif df['R_Score'] >= 3 and df['F_Score'] >= 3:
        return 'Loyal Customers'
    elif df['R_Score'] >= 3 and df['F_Score'] < 2:
        return 'Recent Customers'
    elif df['R_Score'] < 3 and df['F_Score'] >= 3:
        return 'At Risk'
    elif df['R_Score'] < 2 and df['F_Score'] < 2:
        return 'Lost'
    else:
        return 'Potential'

rfm_data['Segment'] = rfm_data.apply(assign_segment, axis=1)

print("\n--- RFM Segments Assigned (First 5 rows): ---")
print(rfm_data.head())

# --- 4. SAVE THE RFM DATA ---
try:
    rfm_data.to_csv('rfm_customer_data.csv')
    print("\nSuccessfully saved the RFM data to 'rfm_customer_data.csv'")
except Exception as e:
    print(f"\nError saving the file: {e}")

